/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import { PrismaService } from "../../prisma/prisma.service";

import {
  Prisma,
  PlagiarismResult as PrismaPlagiarismResult,
  Document as PrismaDocument,
} from "@prisma/client";

import { DocumentOrderByInput } from "../../document/base/DocumentOrderByInput";
import { Document } from "../../document/base/Document";

export class PlagiarismResultServiceBase {
  constructor(protected readonly prisma: PrismaService) {}

  async count(
    args: Omit<Prisma.PlagiarismResultCountArgs, "select">
  ): Promise<number> {
    return this.prisma.plagiarismResult.count(args);
  }

  async plagiarismResults(
    args: Prisma.PlagiarismResultFindManyArgs
  ): Promise<PrismaPlagiarismResult[]> {
    return this.prisma.plagiarismResult.findMany(args);
  }
  async plagiarismResult(
    args: Prisma.PlagiarismResultFindUniqueArgs
  ): Promise<PrismaPlagiarismResult | null> {
    return this.prisma.plagiarismResult.findUnique(args);
  }
  async createPlagiarismResult(
    args: Prisma.PlagiarismResultCreateArgs
  ): Promise<PrismaPlagiarismResult> {
    return this.prisma.plagiarismResult.create(args);
  }
  async updatePlagiarismResult(
    args: Prisma.PlagiarismResultUpdateArgs
  ): Promise<PrismaPlagiarismResult> {
    return this.prisma.plagiarismResult.update(args);
  }
  async deletePlagiarismResult(
    args: Prisma.PlagiarismResultDeleteArgs
  ): Promise<PrismaPlagiarismResult> {
    return this.prisma.plagiarismResult.delete(args);
  }

  async getDocument(parentId: string): Promise<PrismaDocument | null> {
    return this.prisma.plagiarismResult
      .findUnique({
        where: { id: parentId },
      })
      .document();
  }
  async AnalyzeDocument(args: DocumentOrderByInput): Promise<Document> {
    throw new Error("Not implemented");
  }
}
